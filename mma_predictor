{"cells":[{"cell_type":"code","execution_count":1,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":562},"executionInfo":{"elapsed":38397,"status":"ok","timestamp":1746846945023,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":240},"id":"bDSTeWKRpPO1","outputId":"efba587d-4c59-4546-8ee8-21bd880c4638"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["\n","     <input type=\"file\" id=\"files-65594304-0be2-4c20-a5b6-d79f4c856024\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-65594304-0be2-4c20-a5b6-d79f4c856024\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "]},"metadata":{}},{"output_type":"stream","name":"stdout","text":["Saving Fight9_data  - Sheet1-9.csv to Fight9_data  - Sheet1-9.csv\n","Outcome Prediction Accuracy: 66.67%\n","Round Prediction Accuracy: 22.22%\n","   wins_diff  losses_diff  last5_diff  SLpM_diff  StrAcc_diff  SApM_diff  \\\n","0         11            8           1      -2.69           -6      -1.69   \n","\n","   StrDef_diff  TDAvg_diff  TDAcc_diff  TDDef_diff  SubAvg_diff  KDAvg_diff  \\\n","0           16        -0.2          27           2         -0.7        0.11   \n","\n","   ranking_diff  age_distance_diff  height_diff  reach_diff  \n","0             2                5.0        -0.05           0  \n","Predicted Winner: Fighter 1\n","Predicted Round the Fight Finishes: 2\n","              Feature    Weight\n","5           SApM_diff -1.204725\n","7          TDAvg_diff  0.879277\n","15         reach_diff -0.571062\n","2          last5_diff  0.496275\n","10        SubAvg_diff  0.481741\n","3           SLpM_diff  0.305767\n","13  age_distance_diff -0.305632\n","6         StrDef_diff  0.099670\n","4         StrAcc_diff -0.070293\n","1         losses_diff -0.059401\n","0           wins_diff  0.059401\n","9          TDDef_diff -0.049613\n","14        height_diff -0.047080\n","8          TDAcc_diff  0.045921\n","11         KDAvg_diff  0.034992\n","12       ranking_diff  0.027831\n"]}],"source":["import pandas as pd\n","from google.colab import files\n","from sklearn.model_selection import train_test_split\n","from sklearn.linear_model import LogisticRegression\n","\n","# Upload the file\n","uploaded = files.upload()\n","\n","# Load data\n","file_name = list(uploaded.keys())[0]\n","df = pd.read_csv(file_name)\n","\n","prime_age = 31.27\n","\n","# Feature Engineering\n","df['wins_diff'] = df['fighter1_wins'] / (df['fighter1_wins'] + df['fighter1_losses']) - df['fighter2_wins'] / (df['fighter2_wins'] + df['fighter2_losses'])\n","df['losses_diff'] = df['fighter1_losses'] / (df['fighter1_wins'] + df['fighter1_losses']) - df['fighter2_losses'] / (df['fighter2_wins'] + df['fighter2_losses'])\n","df['last5_diff'] = df['fighter1_last5'] - df['fighter2_last5']\n","df['SLpM_diff'] = df['fighter1_SLpM'] - df['fighter2_SLpM']\n","df['StrAcc_diff'] = df['fighter1_StrAcc'] - df['fighter2_StrAcc']\n","df['SApM_diff'] = df['fighter1_SApM'] - df['fighter2_SApM']\n","df['StrDef_diff'] = df['fighter1_StrDef'] - df['fighter2_StrDef']\n","df['TDAvg_diff'] = df['fighter1_TDAvg'] - df['fighter2_TDAvg']\n","df['TDAcc_diff'] = df['fighter1_TDAcc'] - df['fighter2_TDAcc']\n","df['TDDef_diff'] = df['fighter1_TDDef'] - df['fighter2_TDDef']\n","df['SubAvg_diff'] = df['fighter1_SubAvg'] - df['fighter2_SubAvg']\n","df['KDAvg_diff'] = df['fighter1_KDAvg'] - df['fighter2_KDAvg']\n","df['ranking_diff'] = df['fighter1_ranking'] - df['fighter2_ranking']\n","df['fighter1_age'] = df['fight_year'] - df['fighter1_birth_year']\n","df['fighter2_age'] = df['fight_year'] - df['fighter2_birth_year']\n","df['fighter1_age_distance'] = abs(df['fighter1_age'] - prime_age)\n","df['fighter2_age_distance'] = abs(df['fighter2_age'] - prime_age)\n","df['age_distance_diff'] = df['fighter1_age_distance'] - df['fighter2_age_distance']\n","df['height_diff'] = df['fighter1_height'] - df['fighter2_height']\n","df['reach_diff'] = df['fighter1_reach'] - df['fighter2_reach']\n","\n","# Prepare features for Model 1 (Predicting the winner)\n","features_outcome = df[['wins_diff', 'losses_diff', 'last5_diff',\n","                       'SLpM_diff', 'StrAcc_diff', 'SApM_diff', 'StrDef_diff',\n","                       'TDAvg_diff', 'TDAcc_diff', 'TDDef_diff',\n","                       'SubAvg_diff', 'KDAvg_diff', 'ranking_diff',\n","                       'age_distance_diff',\n","                       'height_diff', 'reach_diff']]\n","\n","labels_outcome = df['outcome']\n","\n","# Split the data for outcome prediction\n","X_train_outcome, X_test_outcome, y_train_outcome, y_test_outcome = train_test_split(features_outcome, labels_outcome, test_size=0.2, random_state=42)\n","\n","# Train Model 1\n","model_outcome = LogisticRegression(max_iter=1000)  # Increase max_iter if the model doesn't converge\n","model_outcome.fit(X_train_outcome, y_train_outcome)\n","\n","# Evaluate Model 1\n","accuracy_outcome = model_outcome.score(X_test_outcome, y_test_outcome)\n","print(f'Outcome Prediction Accuracy: {accuracy_outcome * 100:.2f}%')\n","\n","# Prepare features for Model 2 (Predicting the round)\n","features_round = df[['wins_diff', 'losses_diff', 'last5_diff',\n","                     'SLpM_diff', 'StrAcc_diff', 'SApM_diff', 'StrDef_diff',\n","                     'TDAvg_diff', 'TDAcc_diff', 'TDDef_diff',\n","                     'SubAvg_diff', 'KDAvg_diff', 'ranking_diff',\n","                     'age_distance_diff',\n","                     'height_diff', 'reach_diff']]\n","\n","labels_round = df['round_finished']\n","\n","# Split the data for round prediction\n","X_train_round, X_test_round, y_train_round, y_test_round = train_test_split(features_round, labels_round, test_size=0.2, random_state=42)\n","\n","# Train Model 2\n","model_round = LogisticRegression(max_iter=1000)  # Increase max_iter if the model doesn't converge\n","model_round.fit(X_train_round, y_train_round)\n","\n","# Evaluate Model 2\n","accuracy_round = model_round.score(X_test_round, y_test_round)\n","print(f'Round Prediction Accuracy: {accuracy_round * 100:.2f}%')\n","\n","\n","# Calculate differences for new fight\n","new_fight = {\n","    'wins_diff': [29 - 18],\n","    'losses_diff': [14 - 6],\n","    'last5_diff': [9 - 8],\n","    'SLpM_diff': [4.67 - 7.36],\n","    'StrAcc_diff': [50 - 56],\n","    'SApM_diff': [3.88 - 5.57],\n","    'StrDef_diff': [59 - 43],\n","    'TDAvg_diff': [1.04 - 1.24],\n","    'TDAcc_diff': [50 - 23],\n","    'TDDef_diff': [63 - 61],\n","    'SubAvg_diff': [0.4 - 1.1],\n","    'KDAvg_diff': [0.36 - 0.25],\n","    'ranking_diff': [32 - 30],\n","    'age_distance_diff': [abs(prime_age - (2024 - 1983)) - abs(prime_age - (2024 - 1988))],\n","    'height_diff': [1.73 - 1.78],\n","    'reach_diff': [70 - 70],\n","}\n","\n","# Convert to DataFrame\n","new_fight_df = pd.DataFrame(new_fight)\n","\n","print(new_fight_df)\n","\n","\n","# Convert to DataFrame, ensuring it matches training feature columns\n","new_fight_df = pd.DataFrame(new_fight)\n","\n","# Predicting the winner\n","predicted_outcome = model_outcome.predict(new_fight_df)\n","winner = 'Fighter 1' if predicted_outcome[0] == 1 else 'Fighter 2'\n","print('Predicted Winner:', winner)\n","\n","# Predicting the round the fight finishes\n","predicted_round = model_round.predict(new_fight_df)\n","print('Predicted Round the Fight Finishes:', predicted_round[0])\n","\n","# Get the feature names\n","feature_names = features_outcome.columns\n","\n","# Get the weights (coefficients) from the Logistic Regression model\n","weights = model_outcome.coef_[0]  # It's a 2D array, so we take the first row\n","\n","# Create a DataFrame to display the feature names and their corresponding weights\n","feature_weights = pd.DataFrame({'Feature': feature_names, 'Weight': weights})\n","\n","# Sort the DataFrame by the absolute value of the weights (optional, for easier interpretation)\n","feature_weights['abs_weight'] = feature_weights['Weight'].abs()\n","feature_weights = feature_weights.sort_values(by='abs_weight', ascending=False)\n","\n","# Display the feature weights\n","print(feature_weights[['Feature', 'Weight']])\n"]},{"cell_type":"code","source":[],"metadata":{"id":"g4QqI44JX-0K"},"execution_count":null,"outputs":[]},{"cell_type":"code","execution_count":null,"metadata":{"id":"L1HgrEGe1zPi"},"outputs":[],"source":[]},{"cell_type":"markdown","metadata":{"id":"cOO9yCky11xz"},"source":[]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":7872,"status":"ok","timestamp":1727757572573,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":240},"id":"4VCP5XHkqAeo","outputId":"80c393c5-25a2-441e-dcab-bb6d95df122f"},"outputs":[{"data":{"text/html":["\n","     <input type=\"file\" id=\"files-428f5986-1399-4e64-bc69-a303a2eb7202\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-428f5986-1399-4e64-bc69-a303a2eb7202\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "],"text/plain":["<IPython.core.display.HTML object>"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Saving Fight7_data  - Sheet1.csv to Fight7_data  - Sheet1 (2).csv\n","            fighter1         fighter2  fight_year  fighter1_wins  \\\n","0    Jared Cannonier    Caio Borralho        2024             17   \n","1     Tony Ferguson    Michael Chiesa        2024             26   \n","2      Leon Edwards    Belal Muhammad        2024             22   \n","3  Dricus Du Plessis  Israel Adesanya        2024             21   \n","4     Mateusz Gamrot       Dan Hooker        2024             24   \n","\n","   fighter2_wins  fighter1_losses  fighter2_losses  fighter1_last5  \\\n","0             16                7                1             3.0   \n","1             18               10                7             0.0   \n","2             23                3                3             5.0   \n","3             24                2                3             5.0   \n","4             23                2               12             4.0   \n","\n","   fighter2_last5  fighter1_SLpM  ...  fighter1_reach  fighter2_reach  \\\n","0               5           4.49  ...              77              75   \n","1               2           4.91  ...              76              75   \n","2               5           2.68  ...              74              72   \n","3               3           6.18  ...              76              80   \n","4               3           3.23  ...              70              75   \n","\n","   fighter1_headStr  fighter2_headStr  fighter1_subs  fighter2_subs  \\\n","0                63                65       0.117647       0.235294   \n","1                60                74       0.307692       0.631579   \n","2                57                77       0.136364       0.041667   \n","3                65                49       0.500000       0.000000   \n","4                75                63       0.208333       0.291667   \n","\n","   weight_class  round_finished  fight_rounds  outcome  \n","0           185               6             5        0  \n","1           170               1             3        0  \n","2           170               6             5        0  \n","3           185               4             5        1  \n","4           155               4             3        0  \n","\n","[5 rows x 43 columns]\n","Fighter: Merab Dvalishvili, Grappling Rating: 63790.24\n","Fighter: Tom Aspinall, Grappling Rating: 45036.42\n","Fighter: Curtis Blaydes, Grappling Rating: 41428.87\n","Fighter: Umar Nurmagomedov, Grappling Rating: 27473.36\n","Fighter: Sean Brady, Grappling Rating: 25879.00\n","Fighter: Mateusz Gamrot, Grappling Rating: 25363.30\n","Fighter: Benoit Saint Denis, Grappling Rating: 24287.12\n","Fighter: Michael Chiesa, Grappling Rating: 23546.40\n","Fighter: Islam Makhachev, Grappling Rating: 23352.09\n","Fighter: Dricus Du Plessis, Grappling Rating: 20942.12\n","Fighter: Arman Tsarukyan, Grappling Rating: 16625.42\n","Fighter: Illia Topuria, Grappling Rating: 14911.71\n","Fighter: Caio Borralho, Grappling Rating: 12971.33\n","Fighter: Belal Muhammad, Grappling Rating: 12350.51\n","Fighter: Charles Oliveira, Grappling Rating: 12012.62\n","Fighter: Renato Moicano, Grappling Rating: 11792.68\n","Fighter: Gilbert Burns, Grappling Rating: 11764.46\n","Fighter: Brendan Allen, Grappling Rating: 11323.41\n","Fighter: Alexander Volkanovski, Grappling Rating: 9154.60\n","Fighter: Henry Cejudo, Grappling Rating: 8863.80\n","Fighter: Aljamain Sterling, Grappling Rating: 8634.80\n","Fighter: Deiveson Figueiredo, Grappling Rating: 8169.16\n","Fighter: Sean Strickland, Grappling Rating: 6979.42\n","Fighter: King Green, Grappling Rating: 6707.15\n","Fighter: Rodrigo Nascimento, Grappling Rating: 6374.47\n","Fighter: Leon Edwards , Grappling Rating: 6284.27\n","Fighter: Johnny Walker, Grappling Rating: 6271.21\n","Fighter: Dustin Poirier, Grappling Rating: 6234.69\n","Fighter: Jiri Prochazka, Grappling Rating: 6042.16\n","Fighter: Cory Sandhagen , Grappling Rating: 5331.44\n"]}],"source":["import pandas as pd\n","from google.colab import files\n","\n","# Upload the file\n","uploaded = files.upload()\n","\n","# Replace 'Fight4_data  - Sheet1-9.csv' with the name of your uploaded file\n","file_name = list(uploaded.keys())[0]\n","df = pd.read_csv(file_name)\n","print(df.head())  # Display the first few rows to ensure it's loaded correctly\n","\n","# Feature Engineering (example: calculating fighter1 age)\n","df['fighter1_age'] = df['fight_year'] - df['fighter1_birth_year']\n","\n","def calculate_grappling_rating(TDAvg, TDAcc, TDDef, SubAvg, ranking, subs):\n","    return (TDAvg * 16.1751) + (TDAcc * 8.4824) + (TDDef * 1.6889) + (SubAvg * 6.0433 * subs)\n","\n","# Initialize an empty dictionary to store grappling ratings\n","grappling_ratings = {}\n","\n","# Iterate through each row of the DataFrame\n","for index, row in df.iterrows():\n","    # Calculate grappling rating for fighter 1\n","    fighter1_name = row['fighter1']\n","    fighter1_rating = calculate_grappling_rating(\n","        row['fighter1_TDAvg'], row['fighter1_TDAcc'], row['fighter1_TDDef'], row['fighter1_SubAvg'], row['fighter1_ranking'], row['fighter1_subs']\n","    )\n","\n","    # Update the rating in the dictionary\n","    if fighter1_name in grappling_ratings:\n","        grappling_ratings[fighter1_name] += fighter1_rating\n","    else:\n","        grappling_ratings[fighter1_name] = fighter1_rating\n","\n","    # Calculate grappling rating for fighter 2\n","    fighter2_name = row['fighter2']\n","    fighter2_rating = calculate_grappling_rating(\n","        row['fighter2_TDAvg'], row['fighter2_TDAcc'], row['fighter2_TDDef'], row['fighter2_SubAvg'], row['fighter2_ranking'], row['fighter2_subs']\n","    )\n","\n","    # Update the rating in the dictionary\n","    if fighter2_name in grappling_ratings:\n","        grappling_ratings[fighter2_name] += fighter2_rating\n","    else:\n","        grappling_ratings[fighter2_name] = fighter2_rating\n","\n","# Sort the dictionary by rating in descending order\n","sorted_grapplers = dict(sorted(grappling_ratings.items(), key=lambda item: item[1], reverse=True))\n","\n","# Display the top 10 grapplers\n","top_grapplers = list(sorted_grapplers.items())[:30]\n","for fighter, rating in top_grapplers:\n","    print(f'Fighter: {fighter}, Grappling Rating: {rating:.2f}')\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":16576,"status":"ok","timestamp":1731960603142,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":300},"id":"dTuZpy2Bos37","outputId":"e64f7dbc-de69-476d-b376-6013c8159e45"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["\n","     <input type=\"file\" id=\"files-cde340f4-f52a-413d-b6a6-59b64b99129e\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-cde340f4-f52a-413d-b6a6-59b64b99129e\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "]},"metadata":{}},{"output_type":"stream","name":"stdout","text":["Saving Fight9_data  - Sheet2.csv to Fight9_data  - Sheet2 (1).csv\n","        fighter_name  fight_year  fighter_wins  fighter_losses  fighter_last5  \\\n","0   Charles Oliveira        2024            34              10           16.0   \n","1  Shavkat Rakhmonov        2024            18               0           25.0   \n","2     Belal Muhammad        2024            24               3           11.0   \n","3      Leon Edwards         2024            22               4            5.0   \n","4      Illia Topuria        2024            15               0           22.0   \n","\n","   fighter_SLpM  fighter_StrAcc  fighter_SApM  fighter_StrDef  fighter_TDAvg  \\\n","0          3.39              53          3.20              51           2.17   \n","1          4.12              61          2.41              51           1.49   \n","2          4.39              43          3.48              57           2.28   \n","3          2.68              53          2.37              53           1.25   \n","4          4.40              46          3.35              65           1.92   \n","\n","   fighter_TDAcc  fighter_TDDef  fighter_SubAvg  fighter_KDAvg  \\\n","0             40             55             2.8           0.51   \n","1             29            100             1.8           0.30   \n","2             39             89             0.2           0.01   \n","3             36             65             0.4           0.24   \n","4             56             92             1.3           1.07   \n","\n","   fighter_ranking  fighter_birth_year  fighter_height  fighter_reach  \\\n","0                2                1989          1.7780             74   \n","1                3                1994          1.8500             77   \n","2                0                1988          1.8034             72   \n","3                1                1991          1.8300             74   \n","4                0                1997          1.7000             69   \n","\n","   fighter_headStr  fighter_subs  \n","0               58      0.617647  \n","1               68      0.555556  \n","2               77      0.041667  \n","3               57      0.136364  \n","4               72      0.533333  \n","Fighter P4P Points (Descending):\n","1. Tom Aspinall: -4.02\n","2. Alex Pereira : -4.75\n","3. Khamzat Chimaev: -5.28\n","4. Merab Dvalishvili: -6.09\n","5. Dricus Du Plessis: -6.48\n","6. Islam Makachev: -6.99\n","7. Arman Tsarukyan : -7.45\n","8. Illia Topuria: -7.48\n","9. Alexandre Pantoja: -8.05\n","10. Charles Oliveira: -8.09\n","11. Umar Nurmagomedov: -8.94\n","12. Shavkat Rakhmonov: -9.95\n","13. Belal Muhammad: -10.87\n","14. Jon Jones: -11.53\n","15. Sean Strickland: -11.63\n","16. Sean O'Malley: -11.96\n","17. Kamaru Usman: -12.36\n","18. Leon Edwards : -12.73\n","19. Magomed Ankalaev: -12.74\n","20. Ciryl Gane: -13.39\n","21. Dustin Poirier: -13.59\n","22. Alexander Volkonovski: -13.92\n","23. Max Holloway: -14.14\n","24. Israel Adesanya: -16.80\n"]}],"source":["import pandas as pd\n","from google.colab import files\n","\n","# Upload the file\n","uploaded = files.upload()\n","\n","# Replace 'Fight4_data  - Sheet1-9.csv' with the name of your uploaded file\n","file_name = list(uploaded.keys())[0]\n","df = pd.read_csv(file_name)\n","print(df.head())  # Display the first few rows to ensure it's loaded correctly\n","\n","# Define the hardcoded formula for P4P calculation\n","def calculate_p4p(ranking, StrDef, TDAvg, SApM, last5, StrAcc, SLpM, TDAcc, SubAvg, TDDef, KDAvg, losses, wins):\n","    # Hardcoded formula based on the given weights\n","    p4p_score = (\n","      ranking * -0.512767 +\n","      StrDef * -0.134554 +\n","      TDAvg * 0.701685 +\n","      SApM * -0.933650 +\n","      last5 * 0.285926 +\n","      StrAcc * -0.111386 +\n","      SLpM * 0.190803 +\n","      TDAcc * 0.085576 +\n","      SubAvg * 0.382216 +\n","      TDDef * -0.046735 +\n","      KDAvg * 0.051419 +\n","      losses * -0.000119 +\n","      wins * 0.000119\n",")\n","\n","    return p4p_score\n","\n","# Initialize a dictionary (hashmap) to store fighters and their P4P points\n","p4p_dict = {}\n","\n","# Loop through each fight and calculate P4P points for both fighters\n","for index, row in df.iterrows():\n","    # Extract fighter data (adjusting the names to fit your dataset)\n","    fighter_name = row['fighter_name']\n","    fighter_p4p = calculate_p4p(\n","        row['fighter_ranking'],                 # Ranking\n","        row['fighter_StrDef'],                  # StrDef (Significant Strike Defense)\n","        row['fighter_TDAvg'],                  # TDAvg (Takedown Average)\n","        row['fighter_SApM'],                    # SApM (Significant Strikes Absorbed per Minute)\n","        row['fighter_last5'],                   # Last 5 fights\n","        row['fighter_StrAcc'],                  # StrAcc (Significant Strike Accuracy)\n","        row['fighter_SLpM'],                    # SLpM (Significant Strikes Landed per Minute)\n","        row['fighter_TDAcc'],                  # TDAcc (Takedown Accuracy)\n","        row['fighter_SubAvg'],                  # SubAvg (Submission Average)\n","        row['fighter_TDDef'],                  # TDDef (Takedown Defense)\n","        row['fighter_KDAvg'],                   # KDAvg (Knockdown Average)\n","        row['fighter_losses'] / (row['fighter_wins'] + row['fighter_losses']),\n","        row['fighter_wins'] / (row['fighter_wins'] + row['fighter_losses'])\n","    )\n","    # Add to hashmap (overwrite if same fighter)\n","    p4p_dict[fighter_name] = fighter_p4p\n","\n","# Sort the hashmap by P4P points in descending order\n","sorted_p4p = dict(sorted(p4p_dict.items(), key=lambda item: item[1], reverse=True))\n","\n","print(\"Fighter P4P Points (Descending):\")\n","for rank, (fighter, points) in enumerate(sorted_p4p.items(), start=1):\n","    print(f\"{rank}. {fighter}: {points:.2f}\")"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":5790,"status":"ok","timestamp":1727572704064,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":240},"id":"Cn1sOF5NeOE1","outputId":"8046c630-1a5a-4cf0-b783-3b0fd90e0aa5"},"outputs":[{"data":{"text/html":["\n","     <input type=\"file\" id=\"files-36d1d927-eee1-4174-8cab-b8bd36f4af67\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-36d1d927-eee1-4174-8cab-b8bd36f4af67\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "],"text/plain":["<IPython.core.display.HTML object>"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Saving Fight7_data  - Sheet1-13.csv to Fight7_data  - Sheet1-13 (1).csv\n","            fighter1         fighter2  fight_year  fighter1_wins  \\\n","0    Jared Cannonier    Caio Borralho        2024             17   \n","1     Tony Ferguson    Michael Chiesa        2024             26   \n","2      Leon Edwards    Belal Muhammad        2024             22   \n","3  Dricus Du Plessis  Israel Adesanya        2024             21   \n","4     Mateusz Gamrot       Dan Hooker        2024             24   \n","\n","   fighter2_wins  fighter1_losses  fighter2_losses  fighter1_last5  \\\n","0             16                7                1             3.0   \n","1             18               10                7             0.0   \n","2             23                3                3             5.0   \n","3             24                2                3             5.0   \n","4             23                2               12             4.0   \n","\n","   fighter2_last5  fighter1_SLpM  ...  fighter1_height  fighter2_height  \\\n","0               5           4.49  ...             1.80             1.88   \n","1               2           4.91  ...             1.80             1.85   \n","2               5           2.68  ...             1.83             1.78   \n","3               3           6.18  ...             1.83             1.93   \n","4               3           3.23  ...             1.78             1.83   \n","\n","   fighter1_reach  fighter2_reach  fighter1_headStr  fighter2_headStr  \\\n","0              77              75                63                65   \n","1              76              75                60                74   \n","2              74              72                57                77   \n","3              76              80                65                49   \n","4              70              75                75                63   \n","\n","   weight_class  round_finished  fight_rounds  outcome  \n","0           185               6             5        0  \n","1           170               1             3        0  \n","2           170               6             5        0  \n","3           185               4             5        1  \n","4           155               4             3        0  \n","\n","[5 rows x 41 columns]\n","Fighter: Tom Aspinall, Striking Rating: 143741.44\n","Fighter: Sean O'Malley, Striking Rating: 53094.25\n","Fighter: Alex Pereira , Striking Rating: 17476.15\n","Fighter: Benoit Saint Denis, Striking Rating: 15371.84\n","Fighter: Illia Topuria, Striking Rating: 14076.92\n","Fighter: Diego Lopes, Striking Rating: 13893.60\n","Fighter: Justin Gaethje, Striking Rating: 13101.66\n","Fighter: Marlon Vera, Striking Rating: 11702.88\n","Fighter: Dricus Du Plessis, Striking Rating: 9974.89\n","Fighter: Jonathan Martinez, Striking Rating: 9243.56\n","Fighter: Dustin Poirier, Striking Rating: 8539.60\n","Fighter: Paulo Costa, Striking Rating: 8476.08\n","Fighter: Magomed Ankalaev, Striking Rating: 8079.42\n","Fighter: Brian Ortega, Striking Rating: 7416.77\n","Fighter: Dan Hooker, Striking Rating: 7383.06\n","Fighter: Deiveson Figueiredo, Striking Rating: 7340.45\n","Fighter: Alexander Volkanovski, Striking Rating: 7201.76\n","Fighter: Max Holloway, Striking Rating: 7097.90\n","Fighter: Caio Borralho, Striking Rating: 6978.18\n","Fighter: Israel Adesanya, Striking Rating: 6771.76\n","Fighter: Paddy Pimblett, Striking Rating: 6361.41\n","Fighter: King Green, Striking Rating: 6108.40\n","Fighter: Ciryl Gane, Striking Rating: 6016.14\n","Fighter: Jiri Prochazka, Striking Rating: 5538.25\n","Fighter: Johnny Walker, Striking Rating: 5405.90\n","Fighter: Charles Oliveira, Striking Rating: 4671.22\n","Fighter: Dan Ige, Striking Rating: 4351.63\n","Fighter: Henry Cejudo, Striking Rating: 4156.08\n","Fighter: Brendan Allen, Striking Rating: 4056.81\n","Fighter: Sean Strickland, Striking Rating: 4002.38\n"]}],"source":["import pandas as pd\n","from google.colab import files\n","\n","# Upload the file\n","uploaded = files.upload()\n","\n","# Replace 'Fight4_data  - Sheet1-9.csv' with the name of your uploaded file\n","file_name = list(uploaded.keys())[0]\n","df = pd.read_csv(file_name)\n","print(df.head())  # Display the first few rows to ensure it's loaded correctly\n","\n","# Feature Engineering (example: calculating fighter1 age)\n","df['fighter1_age'] = df['fight_year'] - df['fighter1_birth_year']\n","\n","def calculate_striking_rating(SLpM, StrAcc, StrDef, KDAvg, ranking):\n","    return SLpM * StrAcc * StrDef * KDAvg - ranking\n","\n","# Initialize an empty dictionary to store striking ratings\n","striking_ratings = {}\n","\n","# Iterate through each row of the DataFrame\n","for index, row in df.iterrows():\n","    # Calculate striking rating for fighter 1\n","    fighter1_name = row['fighter1']\n","    fighter1_rating = calculate_striking_rating(\n","        row['fighter1_SLpM'], row['fighter1_StrAcc'], row['fighter1_StrDef'], row['fighter1_KDAvg'], row['fighter1_ranking']\n","    )\n","\n","    # Update the rating in the dictionary\n","    if fighter1_name in striking_ratings:\n","        striking_ratings[fighter1_name] += fighter1_rating\n","    else:\n","        striking_ratings[fighter1_name] = fighter1_rating\n","\n","    # Calculate striking rating for fighter 2\n","    fighter2_name = row['fighter2']\n","    fighter2_rating = calculate_striking_rating(\n","        row['fighter2_SLpM'], row['fighter2_StrAcc'], row['fighter2_StrDef'], row['fighter2_KDAvg'], row['fighter2_ranking']\n","    )\n","\n","    # Update the rating in the dictionary\n","    if fighter2_name in striking_ratings:\n","        striking_ratings[fighter2_name] += fighter2_rating\n","    else:\n","        striking_ratings[fighter2_name] = fighter2_rating\n","\n","# Sort the dictionary by rating in descending order\n","sorted_strikers = dict(sorted(striking_ratings.items(), key=lambda item: item[1], reverse=True))\n","\n","# Display the top 10 strikers\n","top_strikers = list(sorted_strikers.items())[:30]\n","for fighter, rating in top_strikers:\n","    print(f'Fighter: {fighter}, Striking Rating: {rating:.2f}')\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":1000},"executionInfo":{"elapsed":21546,"status":"ok","timestamp":1728786433815,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":240},"id":"r7b2K5VimCQR","outputId":"87335008-fcf1-4d0b-c884-9e2a87f36332"},"outputs":[{"data":{"text/html":["\n","     <input type=\"file\" id=\"files-8358beaa-2762-4d3a-9ecf-1e410e516aa9\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-8358beaa-2762-4d3a-9ecf-1e410e516aa9\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "],"text/plain":["<IPython.core.display.HTML object>"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Saving Fight9_data  - Sheet1-3.csv to Fight9_data  - Sheet1-3.csv\n","              fighter1         fighter2  fight_year  fighter1_wins  \\\n","0  Khabib Nurmagomedov   Justin Gaethje        2020             29   \n","1      Jared Cannonier    Caio Borralho        2024             17   \n","2       Tony Ferguson    Michael Chiesa        2024             26   \n","3        Leon Edwards    Belal Muhammad        2024             22   \n","4    Dricus Du Plessis  Israel Adesanya        2024             21   \n","\n","   fighter2_wins  fighter1_losses  fighter2_losses  fighter1_last5  \\\n","0             25                0                5              15   \n","1             16                7                1              11   \n","2             18               10                7               0   \n","3             23                3                3               6   \n","4             24                2                3              18   \n","\n","   fighter2_last5  fighter1_SLpM  ...  fighter1_reach  fighter2_reach  \\\n","0              20           4.10  ...              70              70   \n","1              19           4.49  ...              77              75   \n","2               4           4.91  ...              76              75   \n","3              13           2.68  ...              74              72   \n","4               7           6.18  ...              76              80   \n","\n","   fighter1_headStr  fighter2_headStr  fighter1_subs  fighter2_subs  \\\n","0                86                61       0.379310       0.038462   \n","1                63                65       0.117647       0.235294   \n","2                60                74       0.307692       0.631579   \n","3                57                77       0.136364       0.041667   \n","4                65                49       0.500000       0.000000   \n","\n","   weight_class  round_finished  fight_rounds  outcome  \n","0           155               2             5        1  \n","1           185               6             5        0  \n","2           170               1             3        0  \n","3           170               6             5        0  \n","4           185               4             5        1  \n","\n","[5 rows x 43 columns]\n","Fighter: Tom Aspinall, Power Efficiency Rating: 47.83\n","Fighter: Khalil Rountree, Power Efficiency Rating: 28.58\n","Fighter: Alex Pereira , Power Efficiency Rating: 28.47\n","Fighter: Deiveson Figueiredo, Power Efficiency Rating: 24.84\n","Fighter: Diego Lopes, Power Efficiency Rating: 23.25\n","Fighter: Benoit Saint Denis, Power Efficiency Rating: 20.50\n","Fighter: Israel Adesanya, Power Efficiency Rating: 15.43\n","Fighter: Derrick Lewis, Power Efficiency Rating: 14.55\n","Fighter: Charles Oliveira, Power Efficiency Rating: 13.75\n","Fighter: Caio Borralho, Power Efficiency Rating: 13.30\n","Fighter: Joaquin Buckley, Power Efficiency Rating: 12.89\n","Fighter: Tatsuro Taira, Power Efficiency Rating: 12.49\n","Fighter: Marlon Vera, Power Efficiency Rating: 11.90\n","Fighter: Roman Dolidze, Power Efficiency Rating: 11.04\n","Fighter: Islam Makhachev, Power Efficiency Rating: 10.82\n","Fighter: Sean O'Malley, Power Efficiency Rating: 10.66\n","Fighter: Paddy Pimblett, Power Efficiency Rating: 10.56\n","Fighter: Paulo Costa, Power Efficiency Rating: 9.73\n","Fighter: Henry Cejudo, Power Efficiency Rating: 9.04\n","Fighter: Justin Gaethje, Power Efficiency Rating: 8.99\n"]}],"source":["import pandas as pd\n","from google.colab import files\n","\n","# Upload the file\n","uploaded = files.upload()\n","\n","# Replace 'Fight4_data  - Sheet1-9.csv' with the name of your uploaded file\n","file_name = list(uploaded.keys())[0]\n","df = pd.read_csv(file_name)\n","print(df.head())  # Display the first few rows to ensure it's loaded correctly\n","\n","# Feature Engineering (example: calculating fighter1 age)\n","df['fighter1_age'] = df['fight_year'] - df['fighter1_birth_year']\n","\n","def calculate_power_efficiency(KDAvg, SLpM, headStr, StrAcc):\n","    if SLpM == 0:  # Handle division by zero\n","        return 0\n","    return KDAvg * 100 * StrAcc / (SLpM * headStr)\n","\n","# Initialize an empty dictionary to store power efficiency ratings\n","power_efficiency_ratings = {}\n","\n","# Iterate through each row of the DataFrame\n","for index, row in df.iterrows():\n","    # Calculate power efficiency for fighter 1\n","    fighter1_name = row['fighter1']\n","    fighter1_rating = calculate_power_efficiency(row['fighter1_KDAvg'], row['fighter1_SLpM'], row['fighter1_headStr'], row['fighter1_StrAcc'])\n","\n","    # Update the rating in the dictionary\n","    power_efficiency_ratings[fighter1_name] = fighter1_rating\n","\n","    # Calculate power efficiency for fighter 2\n","    fighter2_name = row['fighter2']\n","    fighter2_rating = calculate_power_efficiency(row['fighter2_KDAvg'], row['fighter2_SLpM'], row['fighter2_headStr'], row['fighter2_StrAcc'])\n","\n","    # Update the rating in the dictionary\n","    power_efficiency_ratings[fighter2_name] = fighter2_rating\n","\n","# Sort the dictionary by rating in descending order\n","sorted_power_efficiency = dict(sorted(power_efficiency_ratings.items(), key=lambda item: item[1], reverse=True))\n","\n","# Display the top 10 hardest hitters\n","top_hardest_hitters = list(sorted_power_efficiency.items())[:20]\n","for fighter, rating in top_hardest_hitters:\n","    print(f'Fighter: {fighter}, Power Efficiency Rating: {rating:.2f}')\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":650},"executionInfo":{"elapsed":4488,"status":"ok","timestamp":1728952117440,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":240},"id":"0wZ3l9BjouVg","outputId":"ef8f4ebf-1ec1-4ffa-d4ae-b7ca45edd94f"},"outputs":[{"data":{"text/html":["\n","     <input type=\"file\" id=\"files-42576e5b-e9a4-408e-a1fa-d95c75623a8a\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-42576e5b-e9a4-408e-a1fa-d95c75623a8a\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "],"text/plain":["<IPython.core.display.HTML object>"]},"metadata":{},"output_type":"display_data"},{"name":"stdout","output_type":"stream","text":["Saving Fight9_data  - Sheet1-3.csv to Fight9_data  - Sheet1-3 (10).csv\n","Mean Age of Winners: 37.50\n","{31: 1, 33: -0.5, 39: 1, 32: -0.5}\n"]},{"data":{"image/png":"iVBORw0KGgoAAAANSUhEUgAAA1kAAAIjCAYAAADxz9EgAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABC80lEQVR4nO3deVxV1f7/8fcB5JADOIMo5piKc06BmhOJQ6ZliWnOQ/XVTOl2lQaHrLDB9FtqZulPSy3NzMoxc8g00hwozSnTmzjgkMlRVEjYvz96eL73BCjiwsOB1/Px2I/rWWetvT/n3F2dt2vvtW2WZVkCAAAAABjh5e4CAAAAACA/IWQBAAAAgEGELAAAAAAwiJAFAAAAAAYRsgAAAADAIEIWAAAAABhEyAIAAAAAgwhZAAAAAGAQIQsAAAAADCJkAUA+tnHjRtlsNm3cuNHdpeSK/v37q1KlSu4uI0+y2WwaPny4u8sAgAKJkAUAedTixYtls9n0+eefZ3ivfv36stls2rBhQ4b3KlasqPDw8NtRosdo3bq16tSp4+4y8rWVK1fKZrMpODhY6enp7i4HANyKkAUAeVSLFi0kSZs3b3Zpdzgc2rNnj3x8fLRlyxaX9xISEpSQkOAce++99+ry5cu69957b0/RKLAWLFigSpUq6eTJk1q/fr27ywEAtyJkAUAeFRwcrMqVK2cIWXFxcbIsS4888kiG9669vhayvLy85OfnJy8v/nWP3JOcnKwvvvhC0dHRatiwoRYsWODukgDArfivLgDkYS1atNCuXbt0+fJlZ9uWLVtUu3ZtdezYUT/88IPLpVlbtmyRzWZT8+bNJWV+T9a1S+f27t2rNm3aqHDhwipfvrxef/31DMd/5513VLt2bRUuXFglSpRQ48aNtXDhwuvWnJqaqrFjx6pRo0YKCAhQkSJF1LJlywyXNv7nP/+RzWbTm2++qVmzZqlq1aqy2+1q0qSJfvzxxwz7XbZsmerUqSM/Pz/VqVMn08sob9WMGTNUu3Zt2e12BQcHa9iwYTp//rxLn19//VXdu3dXUFCQ/Pz8VKFCBfXs2VNJSUnOPmvXrlWLFi1UvHhxFS1aVDVq1NBzzz3nsp+UlBSNGzdO1apVk91uV0hIiP79738rJSXFpV929nU9CxYsUI0aNeTn56dGjRpp06ZNzvc2bNiQ5SWpCxculM1mU1xc3A2P8fnnn+vy5ct65JFH1LNnTy1dulRXrlzJ0O/y5csaMWKESpcurWLFiumBBx7Q8ePHZbPZNH78eJe+x48f18CBAxUYGCi73a7atWtrzpw52f7cAOBOPu4uAACQtRYtWuijjz7S1q1b1bp1a0l/B6nw8HCFh4crKSlJe/bsUb169Zzv1axZU6VKlbrufv/880916NBBDz30kHr06KElS5Zo9OjRqlu3rjp27ChJev/99zVixAg9/PDDevrpp3XlyhX9/PPP2rp1q3r16pXlvh0Ohz744AM9+uijGjJkiC5cuKDZs2crMjJS27ZtU4MGDVz6L1y4UBcuXNDjjz8um82m119/XQ899JAOHz6sQoUKSZK+/vprde/eXaGhoYqNjdUff/yhAQMGqEKFCjn8ZjMaP368JkyYoIiICD355JM6cOCA3n33Xf3444/asmWLChUqpNTUVEVGRiolJUVPPfWUgoKCdPz4cS1fvlznz59XQECAfvnlF91///2qV6+eXnrpJdntdh06dMjl0s709HQ98MAD2rx5s4YOHapatWpp9+7dmjJlig4ePKhly5ZJUrb2dT3ffvutFi1apBEjRshut2vGjBnq0KGDtm3bpjp16qh169YKCQnRggUL9OCDD7qMXbBggapWraqwsLAbHmfBggVq06aNgoKC1LNnT40ZM0ZfffWVHnnkEZd+/fv31+LFi9WnTx/dc889+vbbb9W5c+cM+zt16pTuuece5+IdZcqU0apVqzRo0CA5HA6NHDkyW58fANzGAgDkWb/88oslyZo4caJlWZb1119/WUWKFLHmzZtnWZZlBQYGWtOnT7csy7IcDofl7e1tDRkyxDl+w4YNliRrw4YNzrZWrVpZkqwPP/zQ2ZaSkmIFBQVZ3bt3d7Z17drVql279k3XfPXqVSslJcWl7c8//7QCAwOtgQMHOtuOHDliSbJKlSplnTt3ztn+xRdfWJKsr776ytnWoEEDq1y5ctb58+edbV9//bUlybrzzjtvWFOrVq2u+1lOnz5t+fr6Wu3bt7fS0tKc7dOmTbMkWXPmzLEsy7J27dplSbI+/fTTLPc1ZcoUS5J15syZLPt89NFHlpeXl/Xdd9+5tM+cOdOSZG3ZsiXb+8qKJEuStX37dmfb77//bvn5+VkPPvigsy0mJsay2+0u3+3p06ctHx8fa9y4cTc8zqlTpywfHx/r/fffd7aFh4dbXbt2dem3Y8cOS5I1cuRIl/b+/ftbklyONWjQIKtcuXLW2bNnXfr27NnTCggIsC5dunTDugDAnbhcEADysFq1aqlUqVLOe61++uknJScnO1cPDA8Pd85qxMXFKS0tzXk/1vUULVpUjz32mPO1r6+vmjZtqsOHDzvbihcvrmPHjmV66d71eHt7y9fXV9LfMzbnzp3T1atX1bhxY+3cuTND/6ioKJUoUcL5umXLlpLkrOXkyZOKj49Xv379FBAQ4Ox33333KTQ09KZqy8o333yj1NRUjRw50uX+tSFDhsjf318rVqyQJOfx16xZo0uXLmW6r+LFi0uSvvjiiyxX2fv0009Vq1Yt1axZU2fPnnVubdu2lSTnpZXZ2df1hIWFqVGjRs7XFStWVNeuXbVmzRqlpaVJkvr27auUlBQtWbLE2W/RokW6evWqyzmSlU8++UReXl7q3r27s+3RRx/VqlWr9OeffzrbVq9eLUn6n//5H5fxTz31lMtry7L02WefqUuXLrIsy+X7iYyMVFJSUqbnEQDkJYQsAMjDbDabwsPDnfdebdmyRWXLllW1atUkuYasa/+bnZBVoUIF2Ww2l7YSJUq4/CgePXq0ihYtqqZNm6p69eoaNmxYti9TmzdvnurVqyc/Pz+VKlVKZcqU0YoVK1zuW7qmYsWKGeqQ5Kzl999/lyRVr149w9gaNWpkq54buXaMf+7P19dXVapUcb5fuXJlRUdH64MPPlDp0qUVGRmp6dOnu3yuqKgoNW/eXIMHD1ZgYKB69uypxYsXu4SkX3/9Vb/88ovKlCnjst11112SpNOnT2d7X9eT2Xd211136dKlSzpz5owkqWbNmmrSpInLYhULFizQPffc4zzPrmf+/Plq2rSp/vjjDx06dEiHDh1Sw4YNlZqaqk8//dTZ7/fff5eXl5cqV67sMv6fxzhz5ozOnz+vWbNmZfh+BgwY4PL9AEBexT1ZAJDHtWjRQl999ZV2797tvB/rmvDwcD377LM6fvy4Nm/erODgYFWpUuWG+/T29s603bIs559r1aqlAwcOaPny5Vq9erU+++wzzZgxQ2PHjtWECROy3Pf8+fPVv39/devWTc8++6zKli0rb29vxcbG6rfffstRLXnJ5MmT1b9/f33xxRf6+uuvNWLECMXGxuqHH35QhQoVdMcdd2jTpk3asGGDVqxYodWrV2vRokVq27atvv76a3l7eys9PV1169bVW2+9lekxQkJCJClb+zKhb9++evrpp3Xs2DGlpKTohx9+0LRp02447tdff3XOdGYW6BYsWKChQ4feVC3XAuRjjz2mfv36Zdrn2j2IAJBXEbIAII/77+dlbdmyxeWm/0aNGslut2vjxo3aunWrOnXqZPTYRYoUUVRUlKKiopSamqqHHnpIr7zyimJiYuTn55fpmCVLlqhKlSpaunSpy2zZuHHjclTDnXfeKenvH/T/dODAgRztM6tjHDhwwCWkpqam6siRI4qIiHDpX7duXdWtW1cvvPCCvv/+ezVv3lwzZ87Uyy+/LOnvpfPbtWundu3a6a233tKrr76q559/Xhs2bFBERISqVq2qn376Se3atcswo/hPN9rX9WT2nR08eFCFCxdWmTJlnG09e/ZUdHS0Pv74Y12+fFmFChVSVFTU9b80/R2iChUqpI8++ihD4Nu8ebPefvttHT16VBUrVtSdd96p9PR0HTlyxCWQHTp0yGVcmTJlVKxYMaWlpd3w8wFAXsXlggCQxzVu3Fh+fn5asGCBjh8/7jKTZbfbdffdd2v69OlKTk7O1qWC2fXHH3+4vPb19VVoaKgsy9Jff/2V5bhrP7b/eyZq69at2VoKPDPlypVTgwYNNG/evAzLpO/duzdH+/yniIgI+fr66u2333ape/bs2UpKSnKugOdwOHT16lWXsXXr1pWXl5dz6fVz585l2P+1FRWv9enRo4eOHz+u999/P0Pfy5cvKzk5Odv7up64uDiX+5cSEhL0xRdfqH379i6hqHTp0urYsaPmz5+vBQsWqEOHDipduvQN979gwQK1bNlSUVFRevjhh122Z599VpL08ccfS5IiIyMl/b1M/n975513XF57e3ure/fu+uyzz7Rnz54Mx7x2mSMA5GXMZAFAHufr66smTZrou+++k91ud1nIQPr7ksHJkydLyt79WNnVvn17BQUFqXnz5goMDNS+ffs0bdo0de7cWcWKFcty3P3336+lS5fqwQcfVOfOnXXkyBHNnDlToaGhunjxYo5qiY2NVefOndWiRQsNHDhQ586dcz7DK7v7PHPmjHOm6b9VrlxZvXv3VkxMjCZMmKAOHTrogQce0IEDBzRjxgw1adLEuQDE+vXrNXz4cD3yyCO66667dPXqVecs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ihzNZE2bNk0+Pj5asmSJ3n33XZUvX16StGrVKnXo0MFogdf4+vqqUaNGWrdunbMtPT1d69atU1hYWIb+NWvW1O7duxUfH+/cHnjgAbVp00bx8fEKCQnJlToBAAAAFGw5msmqWLGili9fnqF9ypQpt1zQ9URHR6tfv35q3LixmjZtqqlTpyo5OVkDBgyQJPXt21fly5dXbGys/Pz8VKdOHZfxxYsXl6QM7QAAAABgSo5ClvT35Xj/7//9P/3222/63//9X5UtW1arVq1SxYoVVbt2bZM1OkVFRenMmTMaO3asEhMT1aBBA61evdq5GMbRo0fl5eVRj/4CAAAAkM/YLMuybnbQt99+q44dO6p58+batGmT9u3bpypVqmjSpEnavn27lixZkhu1uoXD4VBAQICSkpLk7+/v7nJkm2BzdwluZY276dMVAADA4/EbMG/8BsxuNsjRtM+YMWP08ssva+3atfL19XW2t23bVj/88ENOdgkAAAAA+UKOQtbu3bv14IMPZmgvW7aszp49e8tFAQAAAICnylHIKl68uE6ePJmhfdeuXc6VBgEAAACgIMpRyOrZs6dGjx6txMRE2Ww2paena8uWLfrXv/6lvn37mq4RAAAAADxGjkLWq6++qpo1ayokJEQXL15UaGio7r33XoWHh+uFF14wXSMAAAAAeIwcLeHu6+ur999/X2PHjtXu3bt18eJFNWzYUNWrVzddHwAAAAB4lBw/J0uSQkJCFBISorS0NO3evVt//vmnSpQoYao2AAAAAPA4ObpccOTIkZo9e7YkKS0tTa1atdLdd9+tkJAQbdy40WR9AAAAAOBRchSylixZovr160uSvvrqKx0+fFj79+/XqFGj9PzzzxstEAAAAAA8SY5C1tmzZxUUFCRJWrlypXr06KG77rpLAwcO1O7du40WCAAAAACeJEchKzAwUHv37lVaWppWr16t++67T5J06dIleXt7Gy0QAAAAADxJjha+GDBggHr06KFy5crJZrMpIiJCkrR161bVrFnTaIEAAAAA4ElyFLLGjx+vOnXqKCEhQY888ojsdrskydvbW2PGjDFaIAAAAAB4khwv4f7www+7vD5//rz69et3ywUBAAAAgCfL0T1Zr732mhYtWuR83aNHD5UqVUoVKlTQzz//bKw4AAAAAPA0OQpZM2fOVEhIiCRp7dq1Wrt2rVat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\n","text/plain":["<Figure size 1000x600 with 1 Axes>"]},"metadata":{},"output_type":"display_data"}],"source":["\n"]},{"cell_type":"code","execution_count":null,"metadata":{"colab":{"base_uri":"https://localhost:8080/","height":86},"executionInfo":{"elapsed":12548,"status":"ok","timestamp":1732904821039,"user":{"displayName":"Swagat Pati","userId":"01504482910966418179"},"user_tz":300},"id":"0IbZlLzX13x9","outputId":"5b2fc6dc-807f-4839-ed0b-ae3f3b052251"},"outputs":[{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.HTML object>"],"text/html":["\n","     <input type=\"file\" id=\"files-fd0114e4-6e01-49d5-b8f4-f344e1fa8ad4\" name=\"files[]\" multiple disabled\n","        style=\"border:none\" />\n","     <output id=\"result-fd0114e4-6e01-49d5-b8f4-f344e1fa8ad4\">\n","      Upload widget is only available when the cell has been executed in the\n","      current browser session. Please rerun this cell to enable.\n","      </output>\n","      <script>// Copyright 2017 Google LLC\n","//\n","// Licensed under the Apache License, Version 2.0 (the \"License\");\n","// you may not use this file except in compliance with the License.\n","// You may obtain a copy of the License at\n","//\n","//      http://www.apache.org/licenses/LICENSE-2.0\n","//\n","// Unless required by applicable law or agreed to in writing, software\n","// distributed under the License is distributed on an \"AS IS\" BASIS,\n","// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n","// See the License for the specific language governing permissions and\n","// limitations under the License.\n","\n","/**\n"," * @fileoverview Helpers for google.colab Python module.\n"," */\n","(function(scope) {\n","function span(text, styleAttributes = {}) {\n","  const element = document.createElement('span');\n","  element.textContent = text;\n","  for (const key of Object.keys(styleAttributes)) {\n","    element.style[key] = styleAttributes[key];\n","  }\n","  return element;\n","}\n","\n","// Max number of bytes which will be uploaded at a time.\n","const MAX_PAYLOAD_SIZE = 100 * 1024;\n","\n","function _uploadFiles(inputId, outputId) {\n","  const steps = uploadFilesStep(inputId, outputId);\n","  const outputElement = document.getElementById(outputId);\n","  // Cache steps on the outputElement to make it available for the next call\n","  // to uploadFilesContinue from Python.\n","  outputElement.steps = steps;\n","\n","  return _uploadFilesContinue(outputId);\n","}\n","\n","// This is roughly an async generator (not supported in the browser yet),\n","// where there are multiple asynchronous steps and the Python side is going\n","// to poll for completion of each step.\n","// This uses a Promise to block the python side on completion of each step,\n","// then passes the result of the previous step as the input to the next step.\n","function _uploadFilesContinue(outputId) {\n","  const outputElement = document.getElementById(outputId);\n","  const steps = outputElement.steps;\n","\n","  const next = steps.next(outputElement.lastPromiseValue);\n","  return Promise.resolve(next.value.promise).then((value) => {\n","    // Cache the last promise value to make it available to the next\n","    // step of the generator.\n","    outputElement.lastPromiseValue = value;\n","    return next.value.response;\n","  });\n","}\n","\n","/**\n"," * Generator function which is called between each async step of the upload\n"," * process.\n"," * @param {string} inputId Element ID of the input file picker element.\n"," * @param {string} outputId Element ID of the output display.\n"," * @return {!Iterable<!Object>} Iterable of next steps.\n"," */\n","function* uploadFilesStep(inputId, outputId) {\n","  const inputElement = document.getElementById(inputId);\n","  inputElement.disabled = false;\n","\n","  const outputElement = document.getElementById(outputId);\n","  outputElement.innerHTML = '';\n","\n","  const pickedPromise = new Promise((resolve) => {\n","    inputElement.addEventListener('change', (e) => {\n","      resolve(e.target.files);\n","    });\n","  });\n","\n","  const cancel = document.createElement('button');\n","  inputElement.parentElement.appendChild(cancel);\n","  cancel.textContent = 'Cancel upload';\n","  const cancelPromise = new Promise((resolve) => {\n","    cancel.onclick = () => {\n","      resolve(null);\n","    };\n","  });\n","\n","  // Wait for the user to pick the files.\n","  const files = yield {\n","    promise: Promise.race([pickedPromise, cancelPromise]),\n","    response: {\n","      action: 'starting',\n","    }\n","  };\n","\n","  cancel.remove();\n","\n","  // Disable the input element since further picks are not allowed.\n","  inputElement.disabled = true;\n","\n","  if (!files) {\n","    return {\n","      response: {\n","        action: 'complete',\n","      }\n","    };\n","  }\n","\n","  for (const file of files) {\n","    const li = document.createElement('li');\n","    li.append(span(file.name, {fontWeight: 'bold'}));\n","    li.append(span(\n","        `(${file.type || 'n/a'}) - ${file.size} bytes, ` +\n","        `last modified: ${\n","            file.lastModifiedDate ? file.lastModifiedDate.toLocaleDateString() :\n","                                    'n/a'} - `));\n","    const percent = span('0% done');\n","    li.appendChild(percent);\n","\n","    outputElement.appendChild(li);\n","\n","    const fileDataPromise = new Promise((resolve) => {\n","      const reader = new FileReader();\n","      reader.onload = (e) => {\n","        resolve(e.target.result);\n","      };\n","      reader.readAsArrayBuffer(file);\n","    });\n","    // Wait for the data to be ready.\n","    let fileData = yield {\n","      promise: fileDataPromise,\n","      response: {\n","        action: 'continue',\n","      }\n","    };\n","\n","    // Use a chunked sending to avoid message size limits. See b/62115660.\n","    let position = 0;\n","    do {\n","      const length = Math.min(fileData.byteLength - position, MAX_PAYLOAD_SIZE);\n","      const chunk = new Uint8Array(fileData, position, length);\n","      position += length;\n","\n","      const base64 = btoa(String.fromCharCode.apply(null, chunk));\n","      yield {\n","        response: {\n","          action: 'append',\n","          file: file.name,\n","          data: base64,\n","        },\n","      };\n","\n","      let percentDone = fileData.byteLength === 0 ?\n","          100 :\n","          Math.round((position / fileData.byteLength) * 100);\n","      percent.textContent = `${percentDone}% done`;\n","\n","    } while (position < fileData.byteLength);\n","  }\n","\n","  // All done.\n","  yield {\n","    response: {\n","      action: 'complete',\n","    }\n","  };\n","}\n","\n","scope.google = scope.google || {};\n","scope.google.colab = scope.google.colab || {};\n","scope.google.colab._files = {\n","  _uploadFiles,\n","  _uploadFilesContinue,\n","};\n","})(self);\n","</script> "]},"metadata":{}},{"output_type":"stream","name":"stdout","text":["Saving Fight9_data  - Sheet2.csv to Fight9_data  - Sheet2.csv\n","CSV data successfully converted to output_file.json\n"]},{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.Javascript object>"],"application/javascript":["\n","    async function download(id, filename, size) {\n","      if (!google.colab.kernel.accessAllowed) {\n","        return;\n","      }\n","      const div = document.createElement('div');\n","      const label = document.createElement('label');\n","      label.textContent = `Downloading \"${filename}\": `;\n","      div.appendChild(label);\n","      const progress = document.createElement('progress');\n","      progress.max = size;\n","      div.appendChild(progress);\n","      document.body.appendChild(div);\n","\n","      const buffers = [];\n","      let downloaded = 0;\n","\n","      const channel = await google.colab.kernel.comms.open(id);\n","      // Send a message to notify the kernel that we're ready.\n","      channel.send({})\n","\n","      for await (const message of channel.messages) {\n","        // Send a message to notify the kernel that we're ready.\n","        channel.send({})\n","        if (message.buffers) {\n","          for (const buffer of message.buffers) {\n","            buffers.push(buffer);\n","            downloaded += buffer.byteLength;\n","            progress.value = downloaded;\n","          }\n","        }\n","      }\n","      const blob = new Blob(buffers, {type: 'application/binary'});\n","      const a = document.createElement('a');\n","      a.href = window.URL.createObjectURL(blob);\n","      a.download = filename;\n","      div.appendChild(a);\n","      a.click();\n","      div.remove();\n","    }\n","  "]},"metadata":{}},{"output_type":"display_data","data":{"text/plain":["<IPython.core.display.Javascript object>"],"application/javascript":["download(\"download_4e0c8ca5-7f11-40b3-af65-e43a07f1c7b0\", \"output_file.json\", 15251)"]},"metadata":{}}],"source":["import json\n","import pandas as pd\n","from google.colab import files\n","\n","# Step 1: Upload the file from your local system\n","uploaded = files.upload()\n","\n","# Step 2: Get the uploaded CSV file name\n","file_name = list(uploaded.keys())[0]\n","\n","# Step 3: Read the CSV file into a pandas DataFrame\n","df = pd.read_csv(file_name)\n","\n","# Step 4: Convert the DataFrame to JSON format\n","data = df.to_dict(orient='records')\n","\n","# Step 5: Specify the path to save the JSON file\n","json_file_path = 'output_file.json'\n","\n","# Step 6: Write JSON data to a file\n","with open(json_file_path, mode='w') as json_file:\n","    json.dump(data, json_file, indent=4)\n","\n","print(f\"CSV data successfully converted to {json_file_path}\")\n","\n","\n","# Download the JSON file to your local machine\n","files.download('output_file.json')\n","\n"]}],"metadata":{"colab":{"provenance":[],"authorship_tag":"ABX9TyN2PrSxf2Bt+wnpuhx17aDm"},"kernelspec":{"display_name":"Python 3","name":"python3"},"language_info":{"name":"python"}},"nbformat":4,"nbformat_minor":0}